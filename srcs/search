/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jaylor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/05/29 09:10:04 by jaylor            #+#    #+#             */
/*   Updated: 2017/11/27 17:38:37 by jaylor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "lemin.h"
#include <fcntl.h>

int main(int argc, char **argv)
{
	t_room	*r;
	t_astar	*a;
	int		fd;
	
	fd = open(argv[1], O_RDONLY);
	a = (t_astar*)malloc(sizeof(t_astar));
	r = (t_room*)malloc(sizeof(t_room));
	init_rooms(r);
	if (get_input(r, fd) == -1)
		return (-1);
	if (get_ants(r) == -1)
		return (-1);
	if	(add_con_to_map(r) == -1)
		return (-1);
	print_input(r);
	ft_Astar_init(r, a);
	if (ft_A_star(r,a) == -1)
		return (-1);
	print_ants(r);
	free_stuff(r, a);		
	return (0);
}

int		free_stuff(t_room *r, t_astar *a)
{
	free_it(r->input);
	free_it(r->map);
	free(r->rooms);
	free(r->connection);
	free(r->comments);
	//free(r->start);
	free(r->bpath);	
	free(a->closed_set);
	free(a->open_set);
	free(a->gscore);
	free(a->fscore);
	free(a->came_from);
	free(a);
	free(r);
	return (0);
}

int		free_it(char **str)
{
	int i;

	i = 0;
	while (str[i] != 0)
		free(str[i++]);
	free(str);		
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jaylor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/05/29 09:10:04 by jaylor            #+#    #+#             */
/*   Updated: 2017/11/26 16:58:46 by jaylor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "lemin.h"

int		chomp_at_dash(t_room *r, int i)
{
 	char    *space;

    space = ft_strchr(r->connection[i], '-');
    *space = '\0';	
	return (0);
}


int		add_con_to_map(t_room *r)
{
	int i;
	int j;
	int k;
	int l;
	int flag;

	i = 0;
	k = 0;
	j = 0;
	l = 0;
	flag = 0;
	while (r->connection[i])
	{
		chomp_at_dash(r, i);
		while (ft_strcmp(r->connection[i], r->rooms[j]) != 0)
		{
			j++;
			if (r->rooms[j] == 0)
			{
				ft_putstr_fd("Major error, no room name exists for a connection", 2);
				return (-1);
			}
		}
		while (r->connection[i][k])
			k++;
		while (ft_strcmp(&r->connection[i][k + 1], r->rooms[l]) != 0)
		{
			l++;
			if (r->rooms[l] == 0)
			{
				ft_putstr_fd("Major error, no room name exists for a connection", 2);
				return (-1);
			}
		}
		r->map[j][l] = '1';
		r->map[l][j] = '1';
		i++;
		j = 0;
		k = 0;
		l = 0;
	}	
	return (0);
}


#include "lemin.h"


int		ft_Astar_init(t_room *r, t_astar *a)
{
	a->x = 0;
	a->y = 0;
	a->z = 0;
	a->current = 0;
	a->neighbor = 0;
	a->closed_set = (int*)malloc(sizeof(int) * 1000000);
	ft_memset(a->closed_set, -1, 1000000);
	a->open_set = (int*)malloc(sizeof(int) * 1000000);
	ft_memset(a->open_set, -1, 1000000);
	a->open_set[0] = 0;
	a->gscore = (int*)malloc(sizeof(int) * 1000000);
	ft_intset(a->gscore, 2147483647, 1000000);
	a->gscore[99999] = -1;
	a->gscore[0] = 0;
	a->fscore = (int*)malloc(sizeof(int) * 1000000);
	ft_intset(a->fscore, 2147483647, 1000000);
	a->fscore[9999] = -1;
	a->fscore[0] = ft_distance(r, 0, r->end);
	a->came_from = (int*)malloc(sizeof(int) * 1000000);
	ft_memset(a->came_from, -1, 1000000);
	return (0);
}

int		ft_A_star(t_room *r, t_astar *a)
{
	while (a->open_set[0] != -1)
	{
		a->current = ft_lowest(a->fscore, a->open_set);
		a->x = (a->z == 0) ? a->x : a->current;
		a->y = (a->z == 0) ? a->current : a->y;
		if (a->current == r->end)
		{
			r->bpath = (ft_reconstruct(a->came_from, a->current));
			return (0);
		}
		ft_remove(a->current, a->open_set);
		ft_add(a->current, a->closed_set);
		while (1)
		{	
			(a->z == 0) ? a->x++ : a->y++;
			while (a->x < r->r_len - 1 && a->y < r->r_len - 1 && r->map[a->x][a->y] == '0')
				(a->z == 0) ? a->x++ : a->y++;
			if (a->x > r->r_len - 1 || a->y > r->r_len - 1)
				break;
			if (r->map[a->x][a->y] != '1')
				break;
			a->neighbor = (a->z == 0) ?	a->x : a->y;
			if (ft_in(a->neighbor, a->closed_set) == 1)
				continue;
			if (ft_in(a->neighbor, a->open_set) == 0)
				ft_add(a->neighbor, a->open_set);
			a->ten_gscore = a->gscore[a->current] + ft_distance(r, a->current, a->neighbor);
			if (a->ten_gscore >= a->gscore[a->neighbor])
				continue;
			a->came_from[a->neighbor] = a->current;
			a->gscore[a->neighbor] = a->ten_gscore;
			a->fscore[a->neighbor] = a->gscore[a->neighbor] + ft_distance(r, a->neighbor, r->end);
			
		}
		a->y = 0;
		a->x = 0;
		a->z = (a->z == 0) ? 1 : 0;
	}	
	ft_putstr_fd("Major error, no solution to map", 2);
	return (-1);
}

int		*ft_reconstruct(int *came_from, int current)
{
	int		*path;

	path = (int*)malloc(sizeof(int) * 1000);
	ft_intset(path, -1, 1000);
	ft_add(current, path);
	while (came_from[current] != -1)
	{
		current = came_from[current];
		ft_add(current, path);
	}
	ft_intrev(path);
	return (path);
}

int		ft_lowest(int *array, int *inthis)
{
	int i;
	int low;
	int ret;
	
	low = 2147483647;	
	i = 0;
	while (inthis[i] != -1)
	{
		if (array[inthis[i]] < low)
		{
			low = array[inthis[i]];
			ret = inthis[i];
		}
		i++;
	}	
	return (ret);
}

int		ft_remove(int rem, int *array)
{
	int i;

	i = 0;
	while (array[i] != rem && array[i] != -1)
		i++;
	if (array[i] == -1)
		return (-1);
	while (array[i + 1] != -1)
	{
		array[i] = array[i + 1];
		i++;
	}
	array[i] = -1;
	return (1);
}


int		ft_add(int add, int *array)
{
	int i;

	i = 0;
	while (array[i] != -1)
		i++;
	array[i] = add;
	return (0);
}

int		ft_in(int num, int *array)
{
	int i;

	i = 0;
	while (array[i] != num && array[i] != -1)
		i++;
	if (array[i] == -1)
		return (0);
	else
		return (1);
}

int		ft_distance(t_room *r, int room_1, int room_2)
{
 	int i;
    char *p;
    int *x;
    int dist;
	int j;

    i = 0;
	j = 0;
    x = (int*)malloc(sizeof(int) * 4);
	while (r->rooms[room_1][j] != ' ')
		j++;
	p = &r->rooms[room_1][j + 1];
		
	x[0] = ft_atoi(p);
	x[1] = ft_atoi(p + ft_intlen(x[0]));
	j = 0;
	while (r->rooms[room_2][j] != ' ')
		j++;
	p = &r->rooms[room_2][j + 1];
	x[2] = ft_atoi(p);
	x[3] = ft_atoi(p + ft_intlen(x[2]));
	dist = ft_abs(x[2] - x[0]) + ft_abs(x[3] - x[1]);
	free(x);
	return (dist);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jaylor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/05/29 09:10:04 by jaylor            #+#    #+#             */
/*   Updated: 2017/11/27 12:11:01 by jaylor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "lemin.h"

int		get_ants(t_room *r)
{
	int i;
	int k;
	int f;
	int ret;

	i = 0;
	k = 0;
	f = 0;
	r->start = NULL;
	while (r->input[k])
	{
		i = 0;
		ret = pick(r, &k, &i, &f);
		if (ret == 1)
			break;
		if (ret == -1)
			return (-1);
		k++;
	}
	r->ants = ft_atoi(r->input[k++]);
	if (parse_start(r, k) == -1)
		return (-1);
	return (0);
}

int		pick(t_room *r, int *k, int *i, int *f)
{
	while (r->input[*k][*i] == ' ')
		(*i)++;
	if (r->input[*k][*i] == '\0')
		return (0);
	else if (r->input[*k][*i] == '#')
	{
		if (*f == 0)
			r->start = r->comments;
		*f = 1;
		comment_parse(r, (*k));
	}
	else 
	{
		while (r->input[*k][*i] != '\0')
		{	
			if (ft_isdigit(r->input[*k][*i]) == 0)
			{
				ft_putstr_fd("Major problem with number of ants", 2);
				return (-1);
			}
			(*i)++;
		}
		return (1);
	}	
	return (0);
}

int		parse_start(t_room *r, int k)	
{
	int 	i;
	char 	**nstart;
	int		j;

	i = 1;
	j = 0;
	nstart = r->connection;
	if (r->start == NULL)
	   r->start = r->comments;
	while (r->input[k])
	{
		j = 0;
		if (which_one(r, &k, &i, &j) == -1)
			return (-1);
		k++;
	}
	*r->connection = 0;
	r->connection = nstart;
	r->comments = r->start;
	if (ft_error_check(r) == -1)
		return (-1);
	if (init_map(r) == -1)
		return (-1);
	move_end(r, --i);
	return (0);
}

int		which_one(t_room *r, int *k, int *i, int *j)
{
	while (r->input[*k][*j] == ' ')
		(*j)++;
	if (r->input[*k][*j] == 'L')
	{
		ft_putstr_fd("Major error, room name starts with L", 2);
		return (-1);
	}
	if (r->input[*k][*j] == '#')
	{
		if (r->input[*k][*j + 1] == '#')
		{
			if (ft_strcmp(&r->input[*k][*j + 2], "start") == 0)
				 return ((found_start(r, k)) ? 0 : -1);
			if (ft_strcmp(&r->input[*k][*j + 2], "end") == 0)
				 return ((found_end(r, k, i)) ? 0 : -1);
		}
		comment_parse(r, *k);
		return (0);
	}
	if (ft_strchr(r->input[*k], '-'))
		connection_parse(r, *k, i);
	if (ft_strchr(r->input[*k], ' '))
	{
		if (room_parse(r, *k, i) == -1)
			return (-1);
	}
	return (0);
}


int		ft_shitmove(t_room *r, int k, int j)
{
	int i;
	int save;
	int len;

	save = j;
	i = 0;
	len = ft_strlen(r->input[k]) - save;
	while (len--)
		r->input[k][i++] = r->input[k][j++];
	while (save--)
		r->input[k][i] = '\0';
	return (0);
}

int		if_valid_room(t_room *r, int k)
{
	char	*space;
	int		f;
	int 	j;

	j = 0;
	f = 0;
	while (r->input[k][j] == ' ')
		j++;
	ft_shitmove(r, k, j);
	if ((space = ft_strchr(&(r->input[k][j]), ' ')) == NULL)
	{	
		ft_putstr_fd("Major error, room position problem", 2);
		return (0);
	}
	space++;
	while (*space == ' ')
		space++;
	while (*space)
    {
		if (f == 1 && *space == ' ')
			break;
        if (ft_isdigit(*space++) != 0)
			f = 1;
		else
		{
			ft_putstr_fd("Major error, room position problem", 2);
            return (0);
		}
    }
	if (f == 0)
	{
		ft_putstr_fd("Major error, room position problem", 2);
		return (0);
	}
	if (if_valid2(r, space) == 0)
		return (0);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jaylor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/05/29 09:10:04 by jaylor            #+#    #+#             */
/*   Updated: 2017/11/27 17:33:53 by jaylor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "lemin.h"

int		room_parse(t_room *r, int k, int *i)
{
	if (if_valid_room(r, k) == 0)
		return (-1);
	chop_at_space(r, k);
	if (check_dups(r, k) == -1)
		return (-1);
	r->rooms[(*i)++] = r->input[k];
	return (0);
}

int		check_dups(t_room *r, int k)
{
	int i;

	i = 0;
	if (r->rooms[i] == (char*)28)
		i++;
	while (r->rooms[i] != 0)
	{
		if (ft_strcmp(r->input[k], r->rooms[i]) == 0)
		{
			ft_putstr_fd("Major error, 2 room names are the same", 2);
			return (-1);
		}
		i++;
	}
	return (0);

}

int 	move_end(t_room *r, int i)
{
	char	*tmp;
	
	tmp = r->rooms[i]; 
	r->rooms[i] = r->rooms[r->end];
	r->rooms[r->end] = tmp;
	r->end = i;
	return (1);
}

int		connection_parse(t_room *r, int k, int *i)
{
	if (if_valid_con(r, k) == 1)
		room_parse(r, k, i);
	else
	{
		*r->connection = r->input[k];
		r->connection++;
	}
	return (0);
}

int		found_start(t_room *r, int *k)
{
	int i;

	i = 1;
	if (r->rooms[0] != (char*)28)
	{
 		ft_putstr_fd("Major error, more than one start room found", 2);	
		return (0);
	}
	while (r->input[*k + i][0] == '\0')
		i++;
	while (r->input[*k + i][0] == '#')
		comment_parse(r, (*k + i++));
	while (r->input[*k + i][0] == '\0')
		i++;
	*k = *k + i;
	if (if_valid_room(r, *k) == 0)
		return (0);
	chop_at_space(r, *k);
	r->rooms[0] = r->input[*k];
	return (1);
}

int		found_end(t_room *r, int *k, int *i)
{
	if (r->end != -1)
	{
 		ft_putstr_fd("Major error, more than one end room found", 2);	
		return (0);
	}
	while (r->input[++(*k)][0] == '#')
		comment_parse(r, *k);
	if (if_valid_room(r, *k) == 0)
		return (0);
	chop_at_space(r, *k);
	r->end = *i;
	r->rooms[(*i)++] = r->input[*k];
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jaylor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/05/29 09:10:04 by jaylor            #+#    #+#             */
/*   Updated: 2017/11/26 17:22:06 by jaylor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "lemin.h"

int		comment_parse(t_room *r, int k)
{
	*r->comments = r->input[k];
	r->comments++;
	return (0);
}

int		if_valid2(t_room *r, char *space)
{
	int f;
	int f1;

	f = 0;
	f1 = 0;
	if (*space == '\0' || *(space + 1) == '\0')
	{
		ft_putstr_fd("Major error, room position problem!!!!!!!", 2);
		return (0);
	}
    space++;
	while (*space == ' ')
		space++;
	while (*space)
    {
		f1 = 1;
		if (ft_isdigit(*space) != 0)
		{
			if (f == 2)
			{
				ft_putstr_fd("Major error, too many room positions", 2);
            	return (0);
			}
			f = 1;
		}
		else if (*space == ' ' && f == 1)
			f = 2;
		else
		{
			ft_putstr_fd("Major error, room position problem!!!!!!!", 2);
            return (0);
		}
		space++;
    }
	if (f1 == 0)
	{	
		ft_putstr_fd("Major error, 2nd room position problem!", 2);
		return (0);
	}
	return (1);	
}

int     if_valid_con(t_room *r, int k)
{
    char    *space;
    int     f;

    f = 0;
    if ((space = ft_strchr(r->input[k], ' ')) == NULL)
        return (0);
    space++;
    while (*space)
    {
        if (f == 1 && *space == ' ')
            break;
        if (ft_isdigit(*space++) != 0)
            f = 1;
        else
            return (0);
    }
    space++;
    while (*space)
    {
        if (ft_isdigit(*space++) == 0)
            return (0);
    }
    return (1);
}

int		fix_connection(t_room *r)
{
	char	*hold;
	int		i;

	i = 0;
	while (r->connection[i])
	{	
		hold = ft_strchr(r->connection[i], '\0');
		*hold = '-';
		i++;
	}
	i = 0;
	while (r->rooms[i])
	{
		hold = ft_strchr(r->rooms[i], '\0');
		*hold = ' ';
		i++;
	}
	return (0);
}

int		print_input(t_room *r)
{
	int i;

	i = 0;
	ft_putnbr(r->ants);
    ft_putchar('\n');
    fix_connection(r);
    ft_putstr("##start\n");
  	while (i < r->r_len - 1)
	{
		ft_putstr(r->rooms[i++]);
		ft_putchar('\n');
	}
	ft_putstr("##end\n");
	ft_putstr(r->rooms[i]);
    ft_putchar('\n');
    ft_print2d(r->connection);
    ft_putchar('\n');
	if (ft_print2d(r->comments) != -1)
    	ft_putchar('\n');
  //ft_print2d(r->map);
  	return (0);
}

int		strip_space(char *str, int *j)
{
	while (*str == ' ')
		(*j)++;
	return (0);
}
#include "lemin.h"

void		print_ants(t_room *r)
{
	int i;
	int j;
	int k;
	int f;

	f = 0;
	k = ft_int_array_len(r->bpath) - 1;
	i = 1;
	j = 1;
	while (k--)
		chop_at_space_gen(r->rooms[r->bpath[i++]]);
	k = ft_int_array_len(r->bpath) - 1;
//	while (k--)
//		ft_printf("%s-> ",r->rooms[r->bpath[i++]]);
	k = ft_int_array_len(r->bpath) - 1;
	i = 1;
	while (1) 
	{
		i = 1;
		while (i < j)
		{
			f = 1;
			if (line_print(i, j - (i), r, k)  == 1)
				return;
			i++;
		}
		if (f == 1)
			ft_putchar('\n');
		j++;	
	}
}

int     chop_at_space_gen(char *str)
{
    char    *space;

    space = ft_strchr(str, ' ');
    *space = '\0';
	return (0);
}

int		line_print(int i, int j, t_room *r, int k)
{
	if ((j > k || i >= r->ants + 1) )
	{
		if (j > k && i >= r->ants)
			return (1);
		return (0);
	}
//	ft_printf("L%d-%s ", i, r->rooms[r->bpath[j]]);
	ft_putchar('L');
	ft_putnbr(i);
	ft_putchar('-');
	ft_putstr(r->rooms[r->bpath[j]]);
	ft_putchar(' ');
	return (2);
}
#include "lemin.h"

int		init_rooms(t_room *r)
{
	r->rooms = (char**)malloc(sizeof(char*) * 500000);
	ft_memset(r->rooms, 0, 500000);
   	r->rooms[0] = (char*)28;	
	r->input = (char**)malloc(sizeof(char*) * 1000000);
	ft_memset(r->input, 0, 1000000); 
	r->connection = (char**)malloc(sizeof(char*) * 1000000);
	ft_memset(r->connection, 0, 1000000); 
	r->comments = (char**)malloc(sizeof(char*) * 1000);
	ft_memset(r->comments, 0, 1000); 
	r->end = -1;
	r->short_dis = 2147483647;
	return (0);
}

int		chop_at_space(t_room *r, int k)
{
	char	*space;

	space = ft_strchr(r->input[k], ' ');
	*space = '\0';
	return (0);
}

int		init_map(t_room *r)
{
	int i;

	i = 0;
	r->map = (char**)malloc(sizeof(char*) * (r->r_len + 1));
	if (r->map == NULL)
	{		
		ft_putstr_fd("Major error, no MALLOC FAILLED", 2);
		return (-1);
	}	
	r->map[r->r_len] = 0;
	while (i < r->r_len)
	{
		r->map[i] = ft_strnew(r->r_len);
		ft_memset(r->map[i++], '0', r->r_len);
	}
	return (0);
}

int     get_input(t_room *r, int fd)
{
    char    *line;

    r->start = r->input;
    while (get_next_line(fd, &line) > 0)
    {
        *r->input = ft_strdup(line);
        r->input++;
        free(line);
    }
    *r->input = 0;
    r->input = r->start;
	if (r->input[0] == 0)
	{
		ft_putstr_fd("Major error, no input", 2);
		return (-1);
	}
	return (0);
}

int		ft_error_check(t_room *r)
{
	if (r->end == 0)
		{
			ft_putstr_fd("Major error, no end room", 2);
			return (-1);
		}
		if (r->rooms[0] == (char*)28)
		{
			ft_putstr_fd("Major error, no start room", 2);
			return (-1);
		}
	r->r_len = ft_list_len(r->rooms);
	if (r->r_len == 0)
	{
		ft_putstr_fd("Major error, no rooms!", 2);
		return (-1);
	}
	if (ft_list_len(r->connection) == 0)
	{
		ft_putstr_fd("Major error, no connections!", 2);
		return (-1);
	}	
	return (0);
}
